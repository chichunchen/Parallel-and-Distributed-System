#!/usr/bin/env python

import argparse


class DepNode:
    def __init__(self):
        self.time = 0
        self.ndeps = 0
        self.dep_set = set()  # set that this node depends on
        self.starttime = 0
        self.processor = -1

    def set(self, time, ndeps):
        self.time = time
        self.ndeps = ndeps


class DepGraph:
    def __init__(self, filename):
        f = open(filename, 'r')
        firstline = f.readline().split()

        assert len(firstline) == 2
        nodes, edges = [(int(x)) for x in firstline]

        # init all instance variables
        self.nodemap = {}
        for x in range(0, nodes):
            self.nodemap[x] = DepNode()
        self.nodes = nodes
        self.edges = edges
        self.deps_pool = set()
        self.no_deps_pool = set()
        self.done_set = set()

        # read line from file
        for line in f:
            node_arr = line.split()
            taskid = int(node_arr[0])
            time = int(node_arr[1])
            ndeps = int(node_arr[2])
            for x in node_arr[3:]:
                self.nodemap[int(x)].dep_set.add(taskid)
                self.deps_pool.add(int(x))
            self.nodemap[taskid].set(time, ndeps)

        # assume node number is sequential and always start from zero
        for x in range(0, self.nodes):
            self.no_deps_pool.add(x)

        self.no_deps_pool -= self.deps_pool

        assert len(self.nodemap) == nodes

    # return shortest executing time in no_deps_pool and the set that is done when updating
    # the side effect is updating the executing time in nodes in nodemap
    def shortest_time(self):
        time_iter = map(lambda x: self.nodemap[x].time, self.no_deps_pool)
        min_time = min(time_iter)
        if min_time < 0:
            min_time = 0
        local_done_set = set()

        # update all nodes in non_dep set with minimum executing time
        for x in self.no_deps_pool:
            self.nodemap[x].time -= min_time
            if self.nodemap[x].time == 0:
                self.done_set.add(x)
                local_done_set.add(x)

        self.no_deps_pool -= self.done_set

        return min_time, local_done_set

    # check all nodes with dependences with done_set
    # return nodes with no deps
    def new_no_deps(self, starttime):
        ret = set()
        for x in self.deps_pool:
            temp = self.nodemap[x]
            if self.done_set.issuperset(temp.dep_set):
                ret.add(x)
        for x in ret:
            self.nodemap[x].starttime = starttime
        return ret

    def make_set_right(self, putback_set):
        self.no_deps_pool -= putback_set


class Machine:
    def __init__(self, n):
        self.cores = list(range(0, n))  # use cores as LIFO queue
        self.max = 0

    # assign one task to first core in queue
    def pop(self):
        assigned_core = self.cores.pop(0)
        if self.max < assigned_core:
            self.max = assigned_core
        return assigned_core

    # assign tasks from assign_set
    def assign_cores(self, dgraph, assign_set):
        nodemap = dgraph.nodemap
        if len(assign_set) <= len(self.cores):
            for x in assign_set:
                p = self.pop()
                nodemap[x].processor = p
        else:
            avail_set = set()
            for x in assign_set:
                if len(self.cores) > 0:
                    p = self.pop()
                    nodemap[x].processor = p
                    avail_set.add(x)
                else:
                    break
            unavail_set = assign_set - avail_set
            dgraph.no_deps_pool -= unavail_set
            dgraph.deps_pool |= unavail_set

    # yielding the core by inserting it back to core list
    def push(self, n):
        return self.cores.insert(0, n)

    # yield all the cores that has done their task
    def yield_cores(self, nodemap, done_set):
        for x in done_set:
            node = nodemap[x]
            # yield processor
            self.push(node.processor)

    def core_usage(self):
        # plus one for core-0
        return self.max + 1


class Scheduler:
    def __init__(self, dgraph, nproc):
        self.dgraph = dgraph
        self.nproc = nproc
        self.total_time = 0

        # assume that use nodes as core num is the same as use infinite nodes as core num
        if nproc == 0:
            self.machine = Machine(self.dgraph.nodes)
        else:
            self.machine = Machine(nproc)

    def done(self):
        return self.dgraph.no_deps_pool == set() and self.dgraph.deps_pool == set()

    def schedule(self):
        if self.nproc == 0:
            self.infinite_scheduling()
        else:
            self.resource_constrained_scheduling()

    # Exercise 1
    # 1. find the critical path (the processor that takes longer to done the job) of each graph
    # 2. Find the minimum finite number of processors needed to execute (same executing time)
    def infinite_scheduling(self):
        self.machine.assign_cores(self.dgraph, self.dgraph.no_deps_pool)

        while not self.done():
            done_set = self.update_time()
            self.machine.yield_cores(self.dgraph.nodemap, done_set)
            no_deps = self.dgraph.new_no_deps(self.total_time)
            if no_deps != set():
                self.machine.assign_cores(self.dgraph, no_deps)
                self.dgraph.no_deps_pool.update(no_deps)
                self.dgraph.deps_pool.difference_update(no_deps)

        print("Minimum finite number of processors needed to execute: ",
              self.machine.core_usage())

    def resource_constrained_scheduling(self):
        self.machine.assign_cores(self.dgraph, self.dgraph.no_deps_pool)

        while not self.done():
            done_set = self.update_time()
            self.machine.yield_cores(self.dgraph.nodemap, done_set)
            no_deps = self.dgraph.new_no_deps(self.total_time)
            if no_deps != set():
                self.dgraph.no_deps_pool.update(no_deps)
                self.dgraph.deps_pool.difference_update(no_deps)
                self.machine.assign_cores(self.dgraph, no_deps)

    # update nodemap with shortest executing time and update total time
    # return set of node that has finished their task
    def update_time(self):
        min_time, done_set = self.dgraph.shortest_time()
        self.total_time += min_time
        return done_set

    def write(self, filename):
        with open(filename, "w") as f:
            for k, v in self.dgraph.nodemap.items():
                line = str(k) + " " + str(v.processor) + " " + str(v.starttime) + "\n"
                f.writelines(line)


if __name__ == "__main__":
    p = argparse.ArgumentParser(description="Offline scheduling")
    p.add_argument("taskgraph")
    p.add_argument("output")
    p.add_argument("nproc", help="Processors, 0 for infinite", default=0, type=int)

    args = p.parse_args()

    depGraph = DepGraph(args.taskgraph)
    schd = Scheduler(depGraph, args.nproc)
    schd.schedule()
    schd.write(args.output)
